<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake AI Imortal (BFS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define a fonte Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos adicionais para o jogo */
        .grid-container {
            display: grid;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .cell {
            position: relative;
            box-sizing: border-box;
            border: 1px solid rgba(17, 24, 39, 0.1); /* Cor sutil para as c√©lulas */
        }
        .snake-head {
            background-color: #10b981; /* green-500 */
            border-radius: 50%;
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.7);
        }
        .snake-body {
            background-color: #34d399; /* green-400 */
            border-radius: 4px;
            box-shadow: 0 0 4px rgba(52, 211, 153, 0.5);
        }
        .snake-tail {
            background-color: #047857; /* green-700 */
            border-radius: 4px;
        }
        .food {
            background-color: #ef4444; /* red-500 */
            border-radius: 50%;
            box-shadow: 0 0 12px rgba(239, 68, 68, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .path {
            background-color: rgba(59, 130, 246, 0.3); /* blue-500/30 */
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-950 min-h-screen flex items-center justify-center p-4">

    <div id="app" class="bg-gray-900 rounded-2xl shadow-2xl p-6 max-w-4xl w-full border border-gray-800">
        <div class="text-center mb-4">
            <h1 class="text-4xl font-bold text-green-500 mb-2 flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-500"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg>
                Snake AI Imortal (Safe Path BFS)
            </h1>
            <p class="text-gray-400">
                Busca a rota mais curta para a cereja, garantindo sempre um caminho de escape para a cauda.
            </p>
        </div>

        <div id="stats-grid" class="grid grid-cols-4 gap-3 mb-4 text-center">
            <!-- Stats ser√£o injetadas aqui -->
        </div>

        <div class="flex justify-between items-center mb-4 gap-2 flex-wrap">
            <div id="path-status" class="px-4 py-2 rounded-lg border bg-green-900/50 border-green-700">
                <!-- Status do Caminho injetado aqui -->
            </div>
            <div id="strategy-status" class="bg-gray-700/50 px-4 py-2 rounded-lg border border-gray-600">
                <!-- Estrat√©gia injetada aqui -->
            </div>
          
            <div id="immortal-control" class="flex items-center bg-gray-800 px-3 py-2 rounded-lg border border-gray-700">
                <!-- Controle Imortal injetado aqui -->
            </div>

            <div class="flex gap-2">
                <button id="play-pause-btn" class="bg-green-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-green-700 transition-all flex items-center gap-2 shadow-md hover:shadow-lg">
                    <svg id="play-pause-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <span id="play-pause-text">Iniciar</span>
                </button>
                <button id="hard-reset-btn" class="bg-red-600 text-white px-4 py-2 rounded-lg font-semibold hover:bg-red-700 transition-all flex items-center gap-2 shadow-md hover:shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.746 2.746m12.746 8.508a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.746-2.746M12 3v3m0 12v3"></path><path d="M12 12h.01"></path></svg>
                    Reset
                </button>
            </div>
        </div>
        
        <div class="flex justify-center mb-4 gap-4">
            <div id="auto-reset-control" class="bg-gray-800 px-3 py-2 rounded-lg border border-gray-700 flex items-center gap-2">
                <label class="text-xs text-gray-400">Auto-reset:</label>
                <input id="auto-reset-input" type="number" value="200" min="10" max="900" class="w-16 px-2 py-1 bg-gray-700 text-white text-sm rounded border border-gray-600 focus:border-blue-500 focus:outline-none"/>
                <span class="text-xs text-gray-400">c√©lulas</span>
            </div>

            <div id="speed-control" class="bg-gray-800 px-3 py-2 rounded-lg border border-gray-700 flex items-center gap-2">
                <label class="text-xs text-gray-400">Velocidade (ms):</label>
                <input id="game-delay-input" type="number" value="60" min="1" max="500" class="w-16 px-2 py-1 bg-gray-700 text-white text-sm rounded border border-gray-600 focus:border-blue-500 focus:outline-none"/>
            </div>
        </div>

        <div id="game-area-container" class="relative bg-black rounded-lg mx-auto border-2 border-green-700/50 shadow-inner shadow-green-900/50" style="width: 540px; height: 540px;">
            <!-- O grid e o jogo ser√£o injetados aqui -->
            <div id="game-grid" class="grid-container absolute inset-0"></div>
            <div id="food-indicator" class="absolute top-2 left-2 bg-red-600/90 text-white px-3 py-1 rounded-lg text-xs font-bold shadow-lg flex items-center gap-2 z-20"></div>
        </div>

        <div class="mt-4 text-center text-sm text-gray-500">
            <p class="flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg>
                Prioridade: 1. Caminho Seguro para Cereja | 2. Caminho para Cauda (Liberar Espa√ßo) | 3. Movimento mais Seguro.
            </p>
            <p id="footer-stats" class="text-xs mt-1">
                <!-- Stats do Footer injetados aqui -->
            </p>
        </div>
      </div>

    <script>
        // --- CONSTANTES ---
        const GRID_SIZE = 30;
        const CELL_SIZE = 18;
        const DEFAULT_GAME_DELAY = 60;
        const AGGRESSIVE_SIZE_THRESHOLD = 25;
        const AGGRESSIVE_HUNGER_THRESHOLD = 50;
        const TIMEOUT_MOVES = 1000;

        // --- ESTADO GLOBAL ---
        let gameState = {};
        let isPlaying = false;
        let gameInterval = null;
        let bestScore = 0;
        let totalGames = 0;
        let generation = 1;
        let isImmortal = false;
        let gameDelay = DEFAULT_GAME_DELAY;
        let visualPath = [];

        // --- REFER√äNCIAS DO DOM ---
        const gameGridEl = document.getElementById('game-grid');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const playPauseText = document.getElementById('play-pause-text');
        const playPauseIcon = document.getElementById('play-pause-icon');
        const hardResetBtn = document.getElementById('hard-reset-btn');
        const autoResetInput = document.getElementById('auto-reset-input');
        const gameDelayInput = document.getElementById('game-delay-input');
        const immortalControlEl = document.getElementById('immortal-control');
        const statsGridEl = document.getElementById('stats-grid');
        const foodIndicatorEl = document.getElementById('food-indicator');
        const footerStatsEl = document.getElementById('footer-stats');
        const pathStatusEl = document.getElementById('path-status');
        const strategyStatusEl = document.getElementById('strategy-status');
        const gameAreaContainerEl = document.getElementById('game-area-container');

        // --- FUN√á√ïES DE UTILIDADE ---

        function generateFood(snakeBody) {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
            } while (snakeBody.some(seg => seg.x === newFood.x && seg.y === newFood.y));
            return newFood;
        }

        function resetGame() {
            const startPos = { x: 15, y: 15 };
            gameState = {
                snake: [startPos],
                food: generateFood([startPos]),
                direction: { x: 1, y: 0 },
                score: 0,
                movesWithoutFood: 0,
                gameOver: false,
                survivalBonus: 0,
                cherriesEaten: 0
            };
            visualPath = [];
            render();
            stopGameLoop();
        }

        function startGameLoop() {
            if (gameInterval) clearInterval(gameInterval);
            if (!gameState.gameOver) {
                gameInterval = setInterval(gameStep, gameDelay);
            }
            isPlaying = true;
            renderUIControls();
        }

        function stopGameLoop() {
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = null;
            isPlaying = false;
            renderUIControls();
        }
        
        // --- L√ìGICA DE PATHFINDING (BFS) ---

        /**
         * Encontra o caminho mais curto entre 'start' e 'target' usando BFS.
         */
        function findPathBFS(start, target, snake) {
            const queue = [{ pos: start, path: [], coordPath: [start] }];
            const visited = new Set([`${start.x},${start.y}`]);
            
            const snakeBody = new Set(
                snake.slice(0, target === snake[snake.length - 1] ? undefined : -1)
                    .map(seg => `${seg.x},${seg.y}`)
            );

            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            while (queue.length > 0) {
                const { pos, path, coordPath } = queue.shift();

                if (pos.x === target.x && pos.y === target.y) {
                    return { directions: path, coordinates: coordPath };
                }

                for (const dir of directions) {
                    let newX = pos.x + dir.x;
                    let newY = pos.y + dir.y;
                    
                    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                        continue;
                    }

                    const newKey = `${newX},${newY}`;

                    if (snakeBody.has(newKey)) {
                        continue;
                    }

                    if (visited.has(newKey)) {
                        continue;
                    }

                    visited.add(newKey);
                    queue.push({
                        pos: { x: newX, y: newY },
                        path: [...path, dir],
                        coordPath: [...coordPath, { x: newX, y: newY }]
                    });
                }
            }
            return null;
        }

        /**
         * Verifica se o caminho para a cauda (escape) √© mantido ap√≥s um movimento.
         */
        function isPathSafe(head, direction, snake, food) {
            const newHead = { x: head.x + direction.x, y: head.y + direction.y };
            
            if (newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE) {
                return false;
            }
            if (snake.slice(0, -1).some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
                return false;
            }
            
            const simulatedSnake = [newHead, ...snake];
            
            if (newHead.x !== food.x || newHead.y !== food.y) {
                simulatedSnake.pop(); 
            }
            
            if (simulatedSnake.length >= GRID_SIZE * GRID_SIZE) return true; 

            const tail = simulatedSnake[simulatedSnake.length - 1];
            const pathResult = findPathBFS(newHead, tail, simulatedSnake);
            
            return pathResult !== null;
        }

        /**
         * Encontra o movimento mais seguro como √∫ltimo recurso.
         */
        function getSafestMove(head, currentDir, snake, food) {
            const directions = [
                currentDir,
                { x: currentDir.y, y: -currentDir.x }, 
                { x: -currentDir.y, y: currentDir.x }, 
            ];
            
            // 1. Tentar manter rota SEGURA (path to tail)
            for (const dir of directions) {
                if (isPathSafe(head, dir, snake, food)) {
                    return dir;
                }
            }
            
            // 2. Se falhar, tentar o movimento que evita apenas COLIS√ÉO IMEDIATA.
            for (const dir of directions) {
                const testHead = { x: head.x + dir.x, y: head.y + dir.y };
                
                if (testHead.x >= 0 && testHead.x < GRID_SIZE && 
                    testHead.y >= 0 && testHead.y < GRID_SIZE &&
                    !snake.slice(0, -1).some(seg => seg.x === testHead.x && seg.y === testHead.y)) {
                    return dir;
                }
            }
            
            return currentDir;
        }

        // --- L√ìGICA DO JOGO (GAME STEP) ---

        function gameStep() {
            if (gameState.gameOver) return;
            
            const prev = gameState;
            const autoResetSize = parseInt(autoResetInput.value) || 200;

            // 1. Condi√ß√£o de Auto-Reset
            if (prev.snake.length >= autoResetSize) {
                // Simplificado: Sem rastreamento de scoreRef, apenas reset
                if (prev.score > bestScore) bestScore = prev.score;
                totalGames++;
                generation++;
                setTimeout(resetGame, 500);
                gameState = { ...prev, gameOver: true, score: prev.score + 1000 }; 
                render();
                return;
            }

            const head = prev.snake[0];
            let newDirection = getSafestMove(head, prev.direction, prev.snake, prev.food);
            let currentStrategy = '‚ö†Ô∏è Modo sobreviv√™ncia (Fallback)';
            let pathCoordinates = [];

            const pathResultToFood = findPathBFS(head, prev.food, prev.snake);
            
            // --- L√ìGICA DE DECIS√ÉO DE IA ---

            if (isImmortal) {
                // MODO IMORTAL: Rota mais curta
                if (pathResultToFood && pathResultToFood.directions.length > 0) {
                    newDirection = pathResultToFood.directions[0];
                    currentStrategy = 'üëë MODO IMORTAL (Rota Direta)';
                    pathCoordinates = pathResultToFood.coordinates;
                    renderPathStatus(true, pathResultToFood.directions.length, currentStrategy);
                } else {
                    currentStrategy = 'üëë MODO IMORTAL (Busca Segura)';
                    renderPathStatus(false, 0, currentStrategy);
                }
            } else {
                // MODO NORMAL: L√≥gica de seguran√ßa
                const shortSnakeAggression = prev.snake.length < AGGRESSIVE_SIZE_THRESHOLD; 
                const shouldForceAggression = prev.movesWithoutFood >= AGGRESSIVE_HUNGER_THRESHOLD;

                if (pathResultToFood && pathResultToFood.directions.length > 0) {
                    const candidateDir = pathResultToFood.directions[0];
                    
                    if (shortSnakeAggression || shouldForceAggression || isPathSafe(head, candidateDir, prev.snake, prev.food)) {
                        newDirection = candidateDir;
                        
                        if (shouldForceAggression) {
                            currentStrategy = 'üî• FOME EXTREMA (Quebra Deadlock)';
                        } else if (shortSnakeAggression) {
                            currentStrategy = `‚ö° Rota Agressiva (Tamanho < ${AGGRESSIVE_SIZE_THRESHOLD})`;
                        } else {
                            currentStrategy = '‚úÖ Rota Segura para Cereja';
                        }
                        
                        pathCoordinates = pathResultToFood.coordinates;
                        renderPathStatus(true, pathResultToFood.directions.length, currentStrategy);
                    } else {
                        // Rota insegura, ir para a cauda
                        const tail = prev.snake[prev.snake.length - 1];
                        const pathResultToTail = findPathBFS(head, tail, prev.snake);
                        
                        if (pathResultToTail && pathResultToTail.directions.length > 0) {
                            newDirection = pathResultToTail.directions[0];
                            currentStrategy = 'üîÑ Limpando Rota (Path to Tail)';
                            pathCoordinates = pathResultToTail.coordinates;
                            renderPathStatus(false, pathResultToTail.directions.length, currentStrategy);
                        } else {
                            renderPathStatus(false, 0, currentStrategy);
                        }
                    }
                } else {
                    // Sem caminho para cereja, ir para a cauda (fallback)
                    const tail = prev.snake[prev.snake.length - 1];
                    const pathResultToTail = findPathBFS(head, tail, prev.snake);
                    
                    if (pathResultToTail && pathResultToTail.directions.length > 0) {
                        newDirection = pathResultToTail.directions[0];
                        currentStrategy = 'üîÑ Cauda (Caminho bloqueado)';
                        pathCoordinates = pathResultToTail.coordinates;
                        renderPathStatus(false, pathResultToTail.directions.length, currentStrategy);
                    } else {
                        renderPathStatus(false, 0, currentStrategy);
                    }
                }
            }
            
            // Renderiza a estrat√©gia (ap√≥s todas as decis√µes de rota)
            renderStrategy(currentStrategy);

            visualPath = pathCoordinates;
            
            // 2. Simular Novo Movimento
            let newHead = {
                x: head.x + newDirection.x,
                y: head.y + newDirection.y
            };

            const isWallCollision = (
                newHead.x < 0 || newHead.x >= GRID_SIZE ||
                newHead.y < 0 || newHead.y >= GRID_SIZE
            );

            const isBodyCollision = (
                prev.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)
            );
            
            // --- TRATAMENTO DE COLIS√ÉO ---
            let shouldBlockMovement = false;
        
            if (isImmortal) {
                // No Modo Imortal, apenas a parede bloqueia. Colis√£o de corpo √© ignorada.
                if (isWallCollision) {
                    shouldBlockMovement = true;
                    currentStrategy = 'üõë Colis√£o de PAREDE Bloqueada (Imortal)';
                }
            } else {
                // No Modo Normal, colis√£o de parede OU corpo √© fatal.
                if (isWallCollision || isBodyCollision) {
                    // Game Over (L√≥gica de Morte Original para o modo NORMAL)
                    if (prev.score > bestScore) bestScore = prev.score;
                    totalGames++;
                    generation++;
                    stopGameLoop();
                    setTimeout(resetGame, 500);
                    gameState = { ...prev, gameOver: true, survivalBonus: 0 };
                    render();
                    return;
                }
            }
            
            if (shouldBlockMovement) {
                // Se o movimento for bloqueado (Modo Imortal e Parede):
                // For√ßa rota√ß√£o e incrementa fome para quebrar o loop.
                const newForcedDirection = { 
                    x: -prev.direction.y, 
                    y: prev.direction.x 
                };
                renderStrategy(currentStrategy);
                
                return { 
                    ...prev, 
                    direction: newForcedDirection,
                    movesWithoutFood: prev.movesWithoutFood + 1 
                }; 
            }
            // Se isImmortal=true e isBodyCollision=true, o c√≥digo continua e usa newHead normalmente.


            // Se o movimento n√£o foi bloqueado nem fatal, prossegue normalmente.
            const newSnake = [newHead, ...prev.snake];
            let newFood = prev.food;
            let newScore = prev.score;
            let newMoves = prev.movesWithoutFood + 1;
            let newCherriesEaten = prev.cherriesEaten;
            let newSurvivalBonus = prev.survivalBonus;

            // 3. Verificar se comeu
            if (newHead.x === prev.food.x && newHead.y === prev.food.y) {
                newCherriesEaten = prev.cherriesEaten + 1;
                newSurvivalBonus = newCherriesEaten === 1 ? 1 : prev.survivalBonus + 1; 
                
                newFood = generateFood(newSnake);
                newScore = prev.score + 100; 
                newMoves = 0;
            } else {
                newSnake.pop(); 
                
                if (prev.cherriesEaten > 0) {
                    newScore = prev.score + prev.survivalBonus;
                }
            }

            // 4. Timeout
            if (newMoves > TIMEOUT_MOVES) {
                if (prev.score > bestScore) bestScore = prev.score;
                totalGames++;
                generation++;
                stopGameLoop();
                setTimeout(resetGame, 500);
                gameState = { ...prev, gameOver: true, survivalBonus: 0 };
                render();
                return;
            }

            gameState = {
                snake: newSnake,
                food: newFood,
                direction: newDirection,
                score: newScore,
                movesWithoutFood: newMoves,
                gameOver: false,
                survivalBonus: newSurvivalBonus,
                cherriesEaten: newCherriesEaten
            };
            
            render();
        }

        // --- FUN√á√ïES DE RENDERIZA√á√ÉO ---

        function renderGameGrid() {
            gameGridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
            gameGridEl.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
            
            // Limpa o grid
            gameGridEl.innerHTML = '';
            
            const cells = [];
            // Adiciona todas as c√©lulas ao DOM
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const x = i % GRID_SIZE;
                const y = Math.floor(i / GRID_SIZE);
                const cell = document.createElement('div');
                cell.className = 'cell absolute bg-gray-900/5';
                // Define a posi√ß√£o da c√©lula para ser usada pelo JS para renderiza√ß√£o
                cell.style.left = `${x * CELL_SIZE}px`;
                cell.style.top = `${y * CELL_SIZE}px`;
                cell.style.width = `${CELL_SIZE}px`;
                cell.style.height = `${CELL_SIZE}px`;
                cell.id = `cell-${x}-${y}`;
                cells.push(cell);
            }
            gameGridEl.append(...cells);

            // 1. Renderizar Caminho Visual (se houver)
            visualPath.slice(1, -1).forEach(seg => {
                const cell = document.getElementById(`cell-${seg.x}-${seg.y}`);
                if (cell) {
                    cell.classList.add('path');
                    cell.style.width = `${CELL_SIZE - 4}px`;
                    cell.style.height = `${CELL_SIZE - 4}px`;
                    cell.style.margin = `2px`;
                }
            });

            // 2. Renderizar Cobra
            gameState.snake.forEach((seg, index) => {
                const cell = document.getElementById(`cell-${seg.x}-${seg.y}`);
                if (cell) {
                    cell.className = 'cell absolute'; // Reset classes
                    if (index === 0) {
                        cell.classList.add('snake-head');
                    } else if (index === gameState.snake.length - 1) {
                        cell.classList.add('snake-tail');
                    } else {
                        cell.classList.add('snake-body');
                    }
                    cell.style.width = `${CELL_SIZE - 2}px`;
                    cell.style.height = `${CELL_SIZE - 2}px`;
                    cell.style.margin = `1px`;
                }
            });

            // 3. Renderizar Comida
            const foodCell = document.getElementById(`cell-${gameState.food.x}-${gameState.food.y}`);
            if (foodCell) {
                foodCell.className = 'cell absolute food animate-pulse';
                foodCell.innerHTML = 'üçí';
                foodCell.style.width = `${CELL_SIZE - 4}px`;
                foodCell.style.height = `${CELL_SIZE - 4}px`;
                foodCell.style.margin = `2px`;
            }
        }

        function renderStats() {
            const statsHTML = `
                <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
                    <div class="text-xs text-gray-400 mb-1">Gera√ß√£o</div>
                    <div class="text-2xl font-bold text-blue-400">#${generation}</div>
                </div>
                <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
                    <div class="text-xs text-gray-400 mb-1">Pontos</div>
                    <div class="text-2xl font-bold text-green-400">${gameState.score.toLocaleString()}</div>
                    ${gameState.cherriesEaten > 0 ? `<div class="text-xs text-yellow-400 mt-1"> +${gameState.survivalBonus}/movimento</div>` : `<div class="text-xs text-gray-500 mt-1">Pegue cereja primeiro</div>`}
                </div>
                <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
                    <div class="text-xs text-gray-400 mb-1">Tamanho</div>
                    <div class="text-2xl font-bold text-purple-400">${gameState.snake.length}</div>
                    <div class="text-xs text-gray-500 mt-1">Reset em ${autoResetInput.value}</div>
                </div>
                <div class="bg-gray-800 p-3 rounded-lg border border-gray-700">
                    <div class="text-xs text-gray-400 mb-1">üçí Cerejas</div>
                    <div class="text-2xl font-bold text-red-400">${gameState.cherriesEaten}</div>
                </div>
            `;
            statsGridEl.innerHTML = statsHTML;
        }
        
        function renderFoodIndicator() {
            if (gameState.snake.length === 0) return;
            const distance = Math.abs(gameState.snake[0].x - gameState.food.x) + Math.abs(gameState.snake[0].y - gameState.food.y);
            foodIndicatorEl.innerHTML = `
                üçí Cereja: (${gameState.food.x}, ${gameState.food.y})
                <span class="text-red-200"> | Dist√¢ncia: ${distance}</span>
            `;
        }
        
        function renderFooterStats() {
            footerStatsEl.innerHTML = `
                Jogos: ${totalGames} | Recorde: ${bestScore.toLocaleString()} pts | Velocidade: ${gameDelay}ms | Timeout: ${TIMEOUT_MOVES} movimentos.
            `;
        }
        
        function renderStrategy(currentStrategy) {
            strategyStatusEl.innerHTML = `
                <span class="text-xs text-gray-400">Estrat√©gia: </span>
                <span class="text-sm font-bold text-white">${currentStrategy}</span>
            `;
        }

        function renderPathStatus(found, length, strategy) {
            const isAggressive = strategy.includes('Agressiva') || strategy.includes('FOME') || strategy.includes('IMORTAL');
            pathStatusEl.className = `px-4 py-2 rounded-lg border ${isAggressive ? 'bg-green-900/50 border-green-700' : 'bg-blue-900/50 border-blue-700'}`;
            const pathText = found ? `‚úì ${length} movimentos` : '‚úó Seguindo Cauda';

            pathStatusEl.innerHTML = `
                <span class="text-xs text-gray-400">Caminho: </span>
                <span class="text-sm font-bold ${found || isAggressive ? 'text-green-400' : 'text-blue-400'}">
                    ${pathText}
                </span>
            `;
        }
        
        function renderUIControls() {
            // Play/Pause button
            if (isPlaying) {
                playPauseText.textContent = 'Pausar';
                playPauseIcon.innerHTML = `<polygon points="10 3 10 21 14 21 14 3 10 3"></polygon><polygon points="14 3 14 21 18 21 18 3 14 3"></polygon>`;
            } else {
                playPauseText.textContent = 'Iniciar';
                playPauseIcon.innerHTML = `<polygon points="5 3 19 12 5 21 5 3"></polygon>`;
            }
        }
        
        function renderImmortalControl() {
            immortalControlEl.innerHTML = `
                <label for="immortalMode" class="text-sm font-semibold text-red-400 cursor-pointer flex items-center gap-2">
                    <input
                        type="checkbox"
                        id="immortalMode"
                        ${isImmortal ? 'checked' : ''}
                        onchange="toggleImmortalMode(this.checked)"
                        class="h-4 w-4 text-red-600 bg-gray-700 border-gray-600 rounded focus:ring-red-500"
                    />
                    Modo Imortal
                </label>
            `;
        }
        
        // Fun√ß√£o de toggle globalmente acess√≠vel
        window.toggleImmortalMode = (checked) => {
            isImmortal = checked;
            renderImmortalControl();
            if (isPlaying) {
                stopGameLoop();
                startGameLoop(); // Reinicia o loop com a nova configura√ß√£o
            }
        };

        function render() {
            renderGameGrid();
            renderStats();
            renderFoodIndicator();
            renderFooterStats();
            renderUIControls();
        }

        // --- INICIALIZA√á√ÉO E EVENTOS ---
        window.onload = function() {
            // Ajustar o tamanho da √°rea do jogo
            gameAreaContainerEl.style.width = `${GRID_SIZE * CELL_SIZE}px`;
            gameAreaContainerEl.style.height = `${GRID_SIZE * CELL_SIZE}px`;

            resetGame();
            renderImmortalControl();

            // Event Listeners
            playPauseBtn.onclick = () => {
                if (isPlaying) {
                    stopGameLoop();
                } else {
                    startGameLoop();
                }
            };

            hardResetBtn.onclick = () => {
                if (bestScore < gameState.score) bestScore = gameState.score;
                generation = 1;
                totalGames = 0;
                resetGame();
            };

            gameDelayInput.onchange = (e) => {
                const newDelay = Math.max(1, parseInt(e.target.value) || DEFAULT_GAME_DELAY);
                gameDelay = newDelay;
                e.target.value = newDelay; // Corrige o valor na UI
                if (isPlaying) {
                    stopGameLoop();
                    startGameLoop();
                }
                renderFooterStats();
            };
            
            autoResetInput.onchange = renderStats; // Atualiza a UI do Auto-reset
        };
    </script>
</body>
</html>
